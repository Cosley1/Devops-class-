ocker 
======
7 years Experience in IT and DevOps:
How applications were deployed in the past and today:
1.  1990S --- 10 years 
2.  2000S ---   
3.  TODAY  

 1) Traditional/Physical Deployment
 2) Virtualized Deployment (Hardware level Isolation) 
 3) Containerized Deployment(OS/Process level Isolation)

====================================
Docker -- Is a containerization software use to create, build and 
          deploy applications as containers
            Build applications  
            ship applications  
            deploy applications  

IQ: How many environment are you supporting in your CURRENT role??
         Development environment    
         Testing/QA environment    
         Production environment 
In docker applications run as containers   

Containers --> contains everything required for an application to run create
               (App Files (code), Dependencies 
              (Softwares +Libraries), ENV vars & Other Configuration files) 
              which is required for a piece of application/process to run.
          app.war   -----> Virtual Machine  
                           java and Tomcat installed and configured  

   app code     = app.war + 
   dependencies = openjdk11+ + tomcat9  

   app code     = app.ear + 
   dependencies = openjdk11+ + jboss/wildFly  

   app code     = app.jar + 
   dependencies = java

Containerization Software/Runtime --> :
  Docker, = over 80% usage  
  Rocket, 
  Pod man, 
  CRI-O, 
  Core-OS,
  Container-D. 

Docker:  
  Is a containerization multi-platform software use to;    
  create, build, ship, share and deploy containerize applications  

O.S --> Cross Platform (Docker can be installed in any O.S)
        Docker Can Be Installed on Linux, Windows OS, macOS  
        Desktops as well as servers.

Docker is available in 2 Editions:

 1) Docker CE: --> Community Edition (Free to use)
 2) Docker EE: --> Enterprise Edition (Commercial/Licensed)
     CE+
     ---
      1) Vendor Support = docker.io 
      2) Additional Features like DTR (Docker Trusted Registry),
      3) UCP (Universal Control Plane) GUI.

Docker is developed in Go Lang/Go Language. 

Docker Desktop (Local Laptops/Desktops) --> 
https://docs.docker.com/engine/install/#desktop
  Developers/DevOps Engineers Systems

Linux Flavors :
 CentOS
 Amazon Linux
 Red Hat   :
 Ubuntu
 Debian
 Fedora
 SUSE Linux …etc.
 
Officially, Docker CE is not supported for Red Hat. 

app1:
    appCode      = app.war  +   
    Dependencies = openjdk11+ + tomcat9

app1:
    appCode      = app.ear  +   
    Dependencies = openjdk11 + JBoss/WildFly

app3: python app 
    appCode      = app  +   
    Dependencies = python

app3: nodeJS app 
    appCode      = app  +   
    Dependencies = npm 

create, build, ship, share and deploy:
Ticket001: Create a Dockerfile to containerize a javabased web application
SCM-GitHub/GitLab/BitBucket -- projectRepo[src/pom.xml/Dockerfile/Jenkinsfile]

Dockerfile
FROM tomcat:8.0.20-jre8
-# [FROM defines the baseImage containing dependencies]
COPY target/tesla.war /usr/local/tomcat/webapps/tesla.war


mvn clean package
   target/tesla.war   

THD = /usr/local/tomcat/ 
THD = /opt/tomcat9  

Install Docker on  Ubuntu
###########################
#!/bin/bash
sudo apt update -y
sudo apt install docker.io -y
sudo service docker start
sudo docker info
sudo hostnamectl set-hostname docker 
sudo usermod -aG docker ubuntu
sudo su - ubuntu    
 


ssh -i "demo31.pem" ubuntu@ec2-52-87-183-168.compute-1.amazonaws.com

ssh -i "demo31.pem" ubuntu@52.87.183.168

docker ps 
You will get permission denied error as a regular user 
doesn't have permissions to execute docker commands. 
Add  the regular user to the docker group.

sudo usermod -aG docker $USER 
     or 
sudo usermod -aG docker ubuntu
sudo su - ubuntu  

-# Exit From Current SSH Terminal & SSH(Login) again . Then execute 
docker ps 


# Amazon Linux
###########################
sudo yum update -y    
sudo yum install docker -y
sudo service docker start
sudo usermod -aG docker ec2-user
sudo su - ec2-user


Add Regular user to docker group
sudo usermod -aG docker  <username>

ex:
sudo usermod -aG docker ec2-user

================================
Dockerfile: --> Dockerfile is a file which contains instructions 
                needed to create a docker image. 
   Dockerfile contains Specific Keywords use to build images by   
   the Docker Daemon
https://github.com/LandmakTechnology/maven-web-application
  ubuntu@docker:~/web$ cat Dockerfile
Dockerfile1:
FROM tomcat:8.0.20-jre8
COPY target/*.war /usr/local/tomcat/webapps/maven-web-app.war


Docker Image: --> It's a package which contains
                 everything (Libraries, Softwares+ENV+Application Code)
                 needed to run your application.

Docker containers: Run time instance of a docker image. 
     If you execute: docker run, 
     a container is created from the image 

IQ: How many environment are you supporting in your CURRENT role??
         Development environment    
         Testing/QA environment    
         Production environment 
In docker applications run as containers   

Automated:
  sudo apt install maven -y  
manual: 
  download the maven software
   and extract it 
   and add to the PATH 

docker build -t image1 .  
docker run --name tesla -d -p 70:8080 image1:latest 
docker run --name -d -p 70:8080 image1
docker run --name -d -p 70:8080 image1:v1 
docker run --name -d -p 70:8080 image1:v6 

docker run --name containerName -d -p hostPort:containerPort image:tag 
  -d = detachable mode  
  -p = port Forwarding 

ubuntu@docker:~/maven-web-application$ cat Dockerfile 
Dockerfile
FROM tomcat:8.0.20-jre8
COPY target/*.war /usr/local/tomcat/webapps/tesla.war

 docker build   
 docker run 

Docker Registry:
1. DockerHub public [80% usage]
2. DTR 
3. AmazonECR 
4. Nexus/
5. JFrog

docker

docker build -t image1 . 
docker push mylandmarktech/maven-web-app:tagname  
docker push mylandmarktech/tesla-web-app:tagname
docker tag image1 mylandmarktech/maven-web-app:31   
docker tag image1 mylandmarktech/tesla-web-app:1  
docker push mylandmarktech/maven-web-app:31   
docker push mylandmarktech/tesla-web-app:1   
 
docker login -u mylandmarktech -p admin@123

docker pull mylandmarktech/tesla-web-app:1

docker run --name tesla -d -p 8080:8080 image1:latest 

http://52.87.183.168:8080/tesla/

Docker images :
Docker containers  
Dockerfile 
Docker Networks 
Docker volumes  
Docker compose  
Docker swarm 

Docker images commands:
  docker build   = create images from a Dockerfile  
  docker tag     = assigns repository name to images 
  docker images    = list images
  docker image ls  = list images
  docker images -q = list image ids 

  docker build/pull/push/tag/images/inspect   
  docker build vs docker image build

ubuntu@docker:~$ docker image

Usage:  docker image COMMAND

Manage images

Commands:
  build       Build an image from a Dockerfile
  history     Show the history of an image
  import      Import the contents from a tarball to create a filesystem image
  inspect     Display detailed information on one or more images
  load        Load an image from a tar archive or STDIN
  ls          List images
  prune       Remove unused images
  pull        Pull an image or a repository from a registry
  push        Push an image or a repository to a registry
  rm          Remove one or more images
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE

What is required to build an image? Dockerfile  
what is required to deploy an application? docker image   

Dockerfile3
FROM jboss/wildfly
COPY target/*war /opt/jboss/wildfly/standalone/deployments/

Dockerfile4
FROM tomcat:8.0.20-jre8
COPY target/*.war /usr/local/tomcat/webapps/tesla.war

Dockerfile5
FROM tomcat:9.0.74-jre8
COPY target/*.war /usr/local/tomcat/webapps/tesla.war

docker image build -t appimage:1 -f DockerfileName pathtotheDockerfile
docker image build -t appimage:1 -f Dockerfile3 . 
docker image build -t appimage:1 -f Dockerfile3 ~
docker image build -t appimage:1 -f Dockerfile3 /home/ubuntu/web/tl/   

    :8080->8080/tcp   tesla

docker run --name containerName -d -p hostPort:containerPort imageName:tag 

docker run --name myapp -d -p 8000:8080 image1  
docker run --name webapp -d -p 8888:8080  
docker run --name pythonapp -d -p 9090:8080   
docker run --name nodeapp -d -p 9191:8080  

http://52.87.183.168:8000/

 netstat -tulpn 
docker pull tomcat
docker pull tomcat:9.0.74-jre8

docker images     =  list images 
docker images -q  = list image IDs ONLY  
docker rmi imageID/name:tag  - delete images 

How to delete an image from a running container?
 1. stop the container and force delete the image by running the commands below;  
      docker stop containerName/ID  && 
      docker rmi -f imageID/name:tag  

Pull images from Public registry [dockerhub] : 
    No athentication is required

Pull images from private registry [ecr/dockerhub/nexus/JFrog] :
    Authentication is required   
    docker login -u username -p password 

push images to Public registry [dockerhub] :
      Authentication is required   
      docker login -u username -p password 

push images to private registry [dockerhub] :
      Authentication is required   
      docker login -u username -p password 

Nexus private docker registry:
==============================
  htttps://8.200.55.9:8081/tesla/tesla-web-app

 image =  mylandmarktech/tesla-web-app:1 [apps code + dependencies]

 docker tag mylandmarktech/tesla-web-app:1 8.200.55.9:8081/tesla/tesla-web-app:1 
   docker login -u admin -p admin123     

 docker push 8.200.55.9:8081/tesla/tesla-web-app:1 

d

Run 'docker image COMMAND --help' for more information on a command.
ubuntu@docker:~$


aws ecr private docker registry:
===============================
aws ecr get-login-password --region us-east-1 | docker login --username \
AWS --password-stdin 287784533479.dkr.ecr.us-east-1.amazonaws.com

docker build -t tesla-web-app .

docker tag mylandmarktech/tesla-web-app:1 \
287784533479.dkr.ecr.us-east-1.amazonaws.com/tesla-web-app:1

docker push 287784533479.dkr.ecr.us-east-1.amazonaws.com/tesla-web-app:1

docker run --name apps -d -p 7000:8080 \
287784533479.dkr.ecr.us-east-1.amazonaws.com/tesla-web-app:1

delete all images using:
===========================
docker images -q  = List image IDs  
docker rmi $(docker images -q)   
docker rmi -f $(docker images -q)  

docker build/ps/images     

docker ps    = List running containers  
docker ps -a = List all containers 

docker ps -q   = List running containers IDs
docker ps -aq  = List all containers IDs 
docker stop containerName/ID  
docker stop   

stop all containers  
==================
docker stop $(docker ps -aq)

deploy an application with docker images in aws ecr private registry: 
=====================================================================
aws ecr get-login-password --region us-east-1 | docker login --username \
AWS --password-stdin 287784533479.dkr.ecr.us-east-1.amazonaws.com

docker pull 287784533479.dkr.ecr.us-east-1.amazonaws.com/tesla-web-app:1

docker run --name apps -d -p 7000:8080 \
287784533479.dkr.ecr.us-east-1.amazonaws.com/tesla-web-app:1

http://52.87.183.168:7000/tesla/

How to delete dangling images
------------------------------
docker system prune  
docker image prune 

Docker images commands:
  docker build   = create images from a Dockerfile  
  docker tag     = assigns repository name to images 
  docker images    = list images
  docker image ls  = list images
  docker images -q = list image ids 

  docker rmi imageID/name:tag     = delete an image
  docker rmi -f imageID/name:tag  = force delete an image

  docker rmi -f a848f84f4894 
  docker rmi -f  $(docker images -q) = deletes all images 
  docker run image2 
  docker pull nginx  
  docker pull alpine  
  docker images prune   

=======================================
docker container commands  :    
=========================
containers are created from docker images  
  a container is a running process/instance of a docker image 

  docker pull   = pull the docker image from the registry
  docker create = use the image to create a container   -      
  docker start  = start the container   
  docker stop   =  stop container
  docker run = docker create + docker start  
docker run --help  
docker container --help  

Docker flow:
  Dockerfile---->DockerImage---->Containers 

Ticket0011 -
  Deploy a java web application using docker: 
    1. use/Create/modify a Dockerfile   
    2. Use the Dockerfile to build a docker image  
    3. Push the image to an image registry[dockerhub/ecr/nexus/JFrog]
    4. pull, inspect and scan the docker image
    5. deploy the application using the image  



docker pull  =   
   docker pull mylandmarktech/maven-web-app:29  
docker inspect  = 
   docker inspect mylandmarktech/maven-web-app:29
docker scan  = 
   docker scan mylandmarktech/maven-web-app:29

docker run --name webappss -d -p 6000:8080 mylandmarktech/maven-web-app:29 

verify:
  curl 
  browser  
http://52.87.183.168:6060/maven-web-app/

http://52.87.183.168:6060/tesla/

   docker run jenkins/jenkins

docker run --name nginx -d -p 80:80 nginx
docker run --name tomcat -d -p 5000:8080 tomcat
docker run --name appName -d -p hostPort:containerPort image:tagname

docker pull mylandmarktech/hello 

docker run --name hello -d -p 3030:80 mylandmarktech/hello
  cli     = curl -v 52.87.183.168:3030 
  browser = 52.87.183.168:3030

docker exec webapps ls webapps

Force Delete a running container  
===============-----------------
docker rm -f containerName/ID  

Delete an exited/stopped container  
===============-----------------
docker rm containerName/ID  

Delete all exited/stopped container
====================================  
docker rm -f $(docker ps -aq)

List ONLY stopped Containers
=================================
docker ps -aq --filter  status="exited" 
docker ps -a --filter  status="exited" 

List Running Containers
=======================
docker ps -a --filter  status="running" 
docker ps 
docker container ls

List All Containers
==================
docker ps -a
docker container ls -a

List only running container ids
==============================
docker ps -q
docker container ls -q


List all container ids
==============================
docker ps -aq
docker container ls -aq

Delete excited/stopped Containers
================================
  docker rm $(docker ps -aq --filter  status="exited")

docker stop containerName/ID  
docker start containerName/ID  
docker pause containerName/ID  
    http://52.87.183.168:3030/
docker unpause containerName/ID  
docker restart containerName/ID 
---

Ticket0012 -
 https://github.com/LandmakTechnology/python-flask-app
  Deploy a pythonapp application using docker: 
    1. use/Create/modify a Dockerfile   
    2. Use the Dockerfile to build a docker image  
    3. Push the image to an image registry[dockerhub/ecr/nexus/JFrog]
    4. pull, inspect and scan the docker image
    5. deploy the application using the image [docker run]  

Dockerfile_pythonapp 
====================
FROM python:3.7
WORKDIR /opt/app
COPY . .
RUN pip install --no-cache-dir -r requirements-prod.txt
EXPOSE 5000
CMD ["python3", "-m", "flask", "run", "--host=0.0.0.0"]

docker buid -t mylandmarktech/python-flask-app:31 .  

docker run --name pythonapp -d -p 9999:5000 mylandmarktech/python-flask-app:31  

  http://52.87.183.168:9999/
     52.87.183.168:9999/  = rootPath 

----
Ticket0012 -
  Deploy a nodeJS web application using docker: 
    1. use/Create/modify a Dockerfile   
    2. Use the Dockerfile to build a docker image  
    3. Push the image to an image registry[dockerhub/ecr/nexus/JFrog]
    4. pull, inspect and scan the docker image
    5. deploy the application using the image  
https://github.com/LandmakTechnology/nodejs-application
Dockerfile_NodeJS 
------------------ 
FROM node:10
WORKDIR /usr/app
COPY . .
RUN npm install
EXPOSE 9981
CMD ["node","app.js"]
---
node.sh 
docker buid -t mylandmarktech/nodejs-fe-app:31 .  
docker push mylandmarktech/nodejs-fe-app:31  
docker run --name nodeapp -d -p 7777:9981 mylandmarktech/nodejs-fe-app:31  

Unable to find image 'mylandmarktech/nodejs-fe-app:31' locally
31: Pulling from mylandmarktech/nodejs-fe-app

RESTFULAPIs:
  52.87.183.168:7777/landmarktechnologies
  52.87.183.168:7777/html
  52.87.183.168:7777/jsonData
  52.87.183.168:7777/queryparam
  52.87.183.168:7777/redirect

  tb.com/login  
  td.com/payment 
  td.com/loans  
  td.com/accounts  

Delete exited/stopped Containers
================================
  docker rm $(docker ps -aq --filter  status="exited")
  docker rm containerId/Name
=====================

Delete running Containers
================================
docker rm -f containerId/Name
   or docker stop containerId/Name && docker rm containerId/Name

Delete all running Containers
================================
docker rm -f $(docker ps -aq --filter  status="running")
docker rm -f $(docker ps -q)

  docker pull   = pull the docker image from the registry
  docker create = use the image to create a container   -      
  docker start  = start the container   
  docker stop   =  stop container
  docker run = docker create + docker start  
  docker run --help  
docker container --help  

Ticket0017:
  Deploy jenkins as a container
      docker pull jenkins/jenkins  
      docker inspect jenkins/jenkins 
      docker scan jenkins/jenkins     
      docker run --name jenkins -d -p 80:8080 jenkins/jenkins   
      52.87.183.168:80 
         cat /var/jenkins_home/secrets/initialAdminPassword
         docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword

Ticket0018:
  Deploy sonarqube as a container
      docker pull sonarqube
      docker inspect sonarqube 
      docker scan sonarqube 
      docker run --name sonar -d -p 808:8080 sonarqube
     52.87.183.168:808

Avoid address/port binding:
===========================
netstat -tulpn  

stop/kill the container
========================
  docker stop <containerId/Name>
    gives warning before stopping the container process 
  docker kill <containerId/Name>
    gives no warning before stopping the container process  

  


pause/unpause 
============
    docker pause <containerId/Name>
    docker unpause <containerId/Name>

In docker applications are deployed in containers:
==============================================  
How to resolves issues occuring in a docker container??
How to troubleshoot or debug applications running as docker containers? :
1. docker ps -a =  
    = This will check if the container is running, paused or exited
      docker unpause; docker start  
2. docker top containerNAME/ID = check resources 
3. docker stats containerNAME/ID    
4. docker logs containerNAME/ID
5. docker exec  = run commands inside the container
   docker exec jenkins ls  
   docker exec -it jenkins   /bin/bash
7. docker inspect containerNAME/ID
8. docker attach containerNAME/ID 
9.  netstat -tulpn  

8:50pm - 9:10pm

docker cp  = use to copy files into the container from the dockerhost  
             and vise versa    

docker pull mylandmarktech/java-web-app:latest
docker pull mylandmarktech/java-web-app:2  

docker run --name javaapp -d -p 80:8080 mylandmarktech/java-web-app:2 
  curl 52.87.183.168:80/java-web-app   

docker cp javaapp:/usr/local/tomcat/logs /home/ubuntu
docker cp nodejs-application/ javaapp:/usr/local/tomcat/
docker cp foo.txt container_id:/foo.txt

docker cp
Container to the system
docker cp <containerName>:</pathOftheContainerFile>  <SystemPath>/<fileName>
docker cp javawebappone:/usr/local/tomcat/logs/catalina.2020-04-23.log  javawebappone.log
system to the Container 

docker cp  <SystemPath>/<fileName><containerName>:</pathOftheContainerFile> 
docker cp  /home/ubunut/test.log javawebappone:/usr/local/tomcat/logs/test.log
docker rename <ContainerId/NameOld> <NewName>
What is difference b/w docker cp & COPY?

imageRegistry[image]---->[container+changes]

What is docker commit?
Using docker commit we can create image from a continer.

docker commit <containerId/Name> <imageName>
docker commit app image3:1  
docker commit d3d580f8b194 newimage:1   


Can we set CPU,RAM limit for the containers while creating?
Yes We set using options while creating a container.
docker run -d --name app -p 8000:8080 mylandmarktech/maven-web-app
docker diff contianerName/ID   

docker commit app image2  

docker container commands:
  docker run/create/start/stop/kill/inspect/logs/top/stats/
  docker diff/update/cp/commit/paus/unpause/ps/ps-a/exec
  docker rm/rm-f/ps -q/   

docker images commands:
  docker build/login/push/pull/tag/images/images prune/  
  docker rmi/rmi-f/system prune 

docker images --help   
docker containers --help 

ubuntu@docker:~$ docker ps
CONTAINER ID   IMAGE                           COMMAND             CREATED          STATUS          PORTS                                   NAMES
d3d580f8b194   mylandmarktech/java-web-app:2   "catalina.sh run"   23 minutes ago   Up 23 minutes   0.0.0.0:80->8080/tcp, :::80->8080/tcp   javaapp


Dockerfiles:
============ 

RUNNING NOTES FOR Dockerfile starts Below:
===============================================

Dockerfiles:
============ 
Dockerfiles are input use to build docker images    
Docker images are input needed/used to create containerised applications  

1#
FROM tomcat:8.0.20-jre8
COPY target/*war /usr/local/tomcat/webapps/tesla.war
2#
FROM tomcat:8.0.20-jre8  
COPY target/app.ear /usr/local/tomcat/webapps/app.war  
3#
FROM jboss/wildfly:latest  
ADD target/*war /opt/jboss/wildfly/standalone/deployments/

            "ExposedPorts": {
                "8080/tcp": {}

DockerImage: --> It's package which contains application code 
        + all it's dependencies(Software+ENV Varibles + Config Files) 
        together.
java-based projects:

  curl -v localhost:6000/landmark 
  curl -v 44.211.75.85:6000/landmark 

Dockerfile keywords:
===================
FROM
MAINTAINER
COPY
ADD
RUN
CMD
ENTRYPOINT
WORKDIR
ENV
EXPOSE
USER
VOLUME
LABEL
ARG

Base image generally contains Libraries and dependencies  :
    java-standalone applications
FROM  openjdk11
   java-web applications
FROM  tomcat:9.0.7-openjdk11 
FROM  jboss/wildfly
  
  docker pull tomcat:9.0.71-jdk17-corretto-al2

FROM --> FROM indicates the  base image(Layers) such as OS(Libraries)
 like centos,alpine,ubuntu or any programatic language(java,python,node,go) 
 or some other sofwares like tomcat,nginx,mysql..etc. Using base image 
 we can create our own image. All sub subsequent instructions(Layers) 
 will be executed/created on top of base image
layers.


Syntax: 
FROM  <ImageName>
Ex:
FROM tomcat:8.0.20-jre8
FROM openjdk:8-alpine
FROM nginx
FROM node
FROM python

MAINTAINER --> It's will be used as comments to describe 
author/owner who is maintaning the docker file.
This instruction allows you to set the Author/Owner of the Image.

MAINTAINER <name>
MAINTAINER <LandmakTechnology mylandmarktech@gmail.com>
MAINTAINER <Docker Community>

COPY  --> Using COPY we can copy files/folders to the image. 
Files/Folders will be copied to the image while building an image.
Using COPY instruction we can COPY local(build context) files or directories(folders) to the image while building image.

COPY target/tesla.war /usr/local/tomcat/ 
COPY . . 

SYTNAX:
======
COPY <source>                <destination> 
      ServerFile/FolderPath   PathInsideImage

ADD -->
     ADD also can copy files to the image while creating image. 
     ADD can copy local files from host server(build context) 
     and also  can download files from remote HTTP/S locations 
     while creating a image.

     https://8.25.3.9:8081/repo/tesla/tesla.war  

ADD https://8.25.3.9:8081/repo/tesla/tesla.war /usr/local/tomcat/  

FROM ubuntu
ADD https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.71/bin/apache-tomcat-9.0.71.tar.gz /opt/


RUN, CMD, ENTRYPOINT:  instructions can be used to execute commands/scripts.
These RUN,CMD,ENTRYPOINT can be defined in 2 forms.

1) -#Shell Form

RUN <command> <arg1> <arg2>
     mkdir /opt/class  
CMD <command> <arg1> <arg2>
      catalina.sh  start  
ENTRYPOINT <commond> <arg1> <arg2>
      /bin/bash -c catalina.sh  start 
     /bin/bash -c catalina run 

2) -#Executable Form

RUN ["command/executable" , "arg1","arg2"]
    ["mkdir" , "/opt/class30"]

CMD ["commond/executable" , "arg1","arg2"]
    ["catalina" , "run"]

ENTRYPOINT ["commond/executable" , "arg1","arg2"]
           ["catalina" , "run"]

RUN --> RUN instruction will  execute commands/scripts.
        RUN commands or instructions will be executed while creating an image on top 
        of the previous layers(Image). 
        Next to run you can mention any command based on base os of image.
        We can have number of RUN instructions in a docker file 
        all the RUN instructions will be exectued one after the other from top to bottom.

  Dockerfile_RUN:  
  FROM tomcat:9.0.71-jdk8-corretto-al2
  ADD target/tesla.war  /usr/local/tomcat/   
  CMD sh catalina.sh run 
  CMD ["catalina", "run"]

Dockerfile_CMD:  
FROM ubuntu
RUN mkdir /opt/class30
RUN touch /opt/class30/jobs
ADD . /opt/class30
CMD pwd  
CMD ["echo", "I am rich"]

docker build -t image2 -f Dockerfile_CMD . 



What is difference b/w RUN & CMD?

RUN instructions will be executed while creating a image. 
CMD Instructions will be executed while creating a container.
We can have more than one RUN keyword in a docker file.
All the RUN keywords will be processed while creating an image in the defined order(top to bottom).

Can we have more than one CMD in dockerfile?
Yes you can have. But only the last one/recent one in the order will be proccessed 
while creating a container.



ENTRYPOINT --> ENTRYPOINT configures a container that will run as an executable.
           ENTRYPOINT is a command or script that is executed when you run the docker container.


Dockerfile_EP:  
FROM ubuntu
RUN mkdir /opt/class30
RUN touch /opt/class30/jobs
ADD . /opt/class30  
ENTRYPOINT ["echo", "I am rich from ENTRYPOINT"]

How is ENTRYPOINT different from CMD?
1. Both are command instructions executed while creating a container 
2. ENTRYPOINT can't be over riden while we can over ride CMD 

ENV --> ENV instruction sets the environment variable and this sets the environment for the subsequent build instructions. It takes two forms: one with a single variableENV <key> <value> and another with multiple variables ENV <key> =<avlue> <key> = <value>.



ARG -> ARG Instruction defines a variable that can be passed at build time. Once it is defined in the Dockerfile you can pass with this flag --build-arg while building the image. We can have multiple ARG instruction in the Dockerfile. ARG is the only instruction that can precede the FROM instruction in the Dockerfile.

ARG values are not available after the image is built. A running container won’t have access to an ARG variable value


EX:

ARG TAG=latest
FROM centos:$TAG
docker build -t <image-name>:<tag> --build-arg TAG=centos8 .


WORKDIR --> WORKDIR  is used to define the working directory of a Docker container at any given time. The command is specified in the Dockerfile.It is optional (default is / , but base image might have set it), but considered a good practice. Subsequent instructions in the Dockerfile, such as RUN , CMD and ENTRYPOINT will operate in this dir.

Ex:

WORKDIR /app


LABEL

The LABEL instruction adds metadata to an image. A LABEL is a key-value pair. To include spaces within a LABEL value, use quotes and backslashes as you would in command-line parsing. A few usage examples:


LABEL branch=develop

LABEL description="This text illustrates"


An image can have more than one label. You can specify multiple labels on a single line.

LABEL label1="value1" label2="value2" other="value3"



USER 

The USER instruction sets the user name (or UID) and optionally the user group (or GID) to use when running the image and for any RUN, CMD and ENTRYPOINT instructions that follow it in the Dockerfile


  
  
EXPOSE

The EXPOSE instruction informs Docker that the container listens on the specified network ports at runtime.

The EXPOSE instruction does not actually publish the port. It functions as a type of documentation between the person who builds the image and the person who runs the container, about which ports are intended to be published. To actually publish the port when running the container, use the -p flag on docker run to publish and map one or more ports.

EXPOSE 8080  




Dockerfile Best practices:
==========================
1. We should use executable over shell form for CMDs and ENTRYPOINTs instructions 
2. Reduce the number of RUN instructions as much as possible. 
   This will reduce the number Layers and keep our images light weight.  
3. Use Official/Trusted docker base images in your Dockerfile 
    FROM ubuntu/tomcat 
4. Use light weight alpine linux where ever possible
   https://hub.docker.com/_/alpine
   ubuntu/centos/alpine   
5. scan images before usage 
     docker scan imageID/Name 

6) Don't install/have unnecassary packages(Softwares) & Don't
   copy unnecassary files & Folders .

7) Don't run container process as root user. Start container
   process(Application) as non root user. 

8) Try to Scan images for fulnerabilites(Clair ,Anchor or Trivy or Inbuilt Scaning in ECR/GCR/ACR).

9) Try to use multi Stage Docker files to reduce size of the image where ever it's applicable 
https://github.com/LandmakTechnology/Dockerfiles

10. Keywords should be in uppercase to distinguish it from arguments 

multi Stage Docker files:
1. Clone  
2. Build  
3. DeployAsContainer 

FROM ubuntu:git 
WORDIR /home/ubuntu/
RUN clone https://git/repo/webapps \ 
    && cd  webapps
    && mvn install 
FROM tomcat:71-jdk8-corretto-al2   


#git
FROM alpine/git as repo
MAINTAINER mylandmarktech@gmail.com
WORKDIR /app
RUN git clone https://github.com/LandmakTechnology/maven-web-application

#Maven
FROM maven:3.5-jdk-8-alpine as build
WORKDIR /app
COPY --from=repo /app/maven-web-application  /app
RUN mvn install

#Tomcat
FROM tomcat:8.0.20-jre8
#COPY  /app/target/*war /usr/local/tomcat/webapps/maven-web-app.war
COPY --from=build /app/target/*war /usr/local/tomcat/webapps/

ubuntu@docker:~/web/laps$ docker system prune
WARNING! This will remove:
  - all stopped containers
  - all networks not used by at least one container
  - all dangling images
  - all dangling build cache



FROM ubuntu:latest
RUN apt-get -y update && apt-get -y upgrade \
RUN apt-get -y install openjdk-8-jdk wget
RUN mkdir /usr/local/tomcat
RUN wget http://apachemirror.wuchna.com/tomcat/tomcat-8/v8.5.46/bin/apache-tomcat-8.5.46.tar.gz -O /tmp/tomcat.tar.gz
RUN cd /tmp && tar xvfz tomcat.tar.gz \
    && cp -Rv /tmp/apache-tomcat-8.5.46/* /usr/local/tomcat/
EXPOSE 8080
CMD /usr/local/tomcat/bin/catalina.sh run

FROM ubuntu:latest
RUN apt-get -y update && apt-get -y upgrade \
    && apt-get -y install openjdk-8-jdk wget \
    &&  mkdir /usr/local/tomcat \
    && wget http://apachemirror.wuchna.com/tomcat/tomcat-8/v8.5.46/bin/apache-tomcat-8.5.46.tar.gz -O /tmp/tomcat.tar.gz
    && cd /tmp && tar xvfz tomcat.tar.gz \
    && cp -Rv /tmp/apache-tomcat-8.5.46/* /usr/local/tomcat/
EXPOSE 8080
CMD /usr/local/tomcat/bin/catalina.sh run

Dockerfile keywords/instructions:
=================================
FROM  
COPY  
ADD 
RUN 
CMD 
ENTRYPOINT 
WORKDIR ENV  
LABEL  
ARG 
USER 
EXPOSE   
VOLUME  
MAINTAINER  

Micro-services and 
Docker networks   
volumes and 
Docker compose  
docker swarm

http://44.211.75.85:3000/landmarktechnologies

curl -v 44.211.75.85:3000/html  

docker run -d -p 30000:9981  mylandmarktech/nodejs-fe-app


FROM amazoncorretto:8-al2-jdk

ENV CATALINA_HOME /usr/local/tomcat
ENV PATH $CATALINA_HOME/bin:$PATH
RUN mkdir -p "$CATALINA_HOME"
WORKDIR $CATALINA_HOME

ARG 
FROM 

ARG TAG=latest
FROM centos:$TAG

docker build -t <image-name>:<tag> --build-arg TAG=centos8 .

  ebay:


Running notes Docker 6 and 7, 
Docker Network and Microservices 
Video from: Jan 28, 2023



9:10pm -- 10:40pm [Questions]

Time Table:
Mon  7pm - 11pm 
Tue  7pm - 11pm 
Sat  12pm -4pm[Live or video]


Date:   May 6, 2023

Dear Engineers,

We won't be holding a LIVE CLASS ON SATURDAY.
Please watch the video below titled;
'Docker Network and Microservices' 
against today's class May 6, 2023.

Regards,

Landmark Technologies.

NB: Our next LIVE class shall be on Monday May 8, 2023.

================================================

running notes  

-----------------------------


Docker networks:
================
What is a network ?
Group of servers/devices connected to each other in a specific network. If Servers
are in same network each one can talk to another server.

Docker network
=============
If One Container has to talk to another Container Using ContainerIP/Name(DNS) in Docker.
Both has to created under same docker network.

If Containers are in two different networks. They can't access each other.

How to list networks in docker?

docker network ls

Default bridge 
custom bridge
host
none
ubuntu@docker:~$ docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
7b51ede636f3   bridge    bridge    local
a00011a24f3f   host      host      local
4a1dde3cd8e5   none      null      local
ubuntu@docker:~$
ubuntu@docker:~$
ubuntu@docker:~$ docker network create tesla
ffc0324f2f3e7340f8b16e8027391d702ccbe0b71620f6da250b7e23e8bbc91f
ubuntu@docker:~$
ubuntu@docker:~$ docker network create -d bridge ebay
f5f83ee43ba1171458d2a823e0df57b2577ebbb2cd05e13dc9030c749ab69472
ubuntu@docker:~$
ubuntu@docker:~$ docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
7b51ede636f3   bridge    bridge    local
f5f83ee43ba1   ebay      bridge    local
a00011a24f3f   host      host      local
4a1dde3cd8e5   none      null      local
ffc0324f2f3e   tesla     bridge    local
ubuntu@docker:~$

We support Java based applications:
===================================
We support nodeJS and .net based applications:
==============================================
spring:
  data:
    mongodb:
      host: ${MONGO_DB_HOSTNAME}  myhost
      port: 27017
      username: ${MONGO_DB_USERNAME}  mydb  
    password: ${MONGO_DB_PASSWORD}     
      database: users
      authentication-database: admin
server:
  port: 8080

docker pull mylandmarktech/spring-boot-mongo
docker pull mongo
We are developing and depoloying:
    stateless applications   
Our applications is developed to write data in a database
statefulll applications

docker run --name springapp -d -p 4000:8080 --network tesla -e MONGO_DB_USERNAME=devdb \
 -e MONGO_DB_PASSWORD=dev@123 -e MONGO_DB_HOSTNAME=mongo mylandmarktech/spring-boot-mongo

docker run --name mongo -d --network tesla -e MONGO_INITDB_ROOT_PASSWORD=dev@123 \
 -e MONGO_INITDB_ROOT_USERNAME=devdb mongo 

      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: example

mongo   
PostgreSQL  
mysql

docker run --name mongo -d --network tesla -e MONGO_INITDB_ROOT_PASSWORD=dev@123 \
 -e MONGO_INITDB_ROOT_USERNAME=devdb -v /home/ubuntu/db:/data/db mongo 

$ docker run --name some-mongo -v /home/ubuntu/db:/data/db -d mongo
  docker run --name some-mongo -v /home/ubuntu/mydata:/data/db -d mongo
  docker run --name some-mongo -v /tmp/mydata:/data/db -d mongo

      -v = volume mapping  
     -e = pass Environmental variables 
     -d = run the container in detachable modev   
     -p = portMapping/ 
     -it= run the container in interactive mode 
     --name=assign a name to the container  
     --network = define a network for the container 

type=Internal Server Error, status=500


spring:
  data:
    mysql:
      host: ${MYSQL_DB_HOSTNAME}
      port: 27017
      username: ${MYSQL_DB_USERNAME}   ${DB-USERNAME}
    password: ${MYSQL_DB_PASSWORD}      ${DB-PWD}
      database: users
      authentication-database: admin
server:
  port: 8080


    environment:  ADMIN 
      MYSQL_ROOT_PASSWORD: example



ubuntu@docker:~$ docker network --help

Usage:  docker network COMMAND

Manage networks

Commands:
  connect     Connect a container to a network
  create      Create a network
  disconnect  Disconnect a container from a network
  inspect     Display detailed information on one or more networks
  ls          List networks
  prune       Remove all unused networks
  rm          Remove one or more networks

Run 'docker network COMMAND --help' for more information on a command.
ubuntu@docker:~$

Usage:  docker network connect [OPTIONS] NETWORK CONTAINER

        docker network connect ebay mongo    
        docker network disconnect tesla mongo  

docker network create/inspect/ls/disconnect/connect/rm/prune:
============================================================

-# Remove unused networks
docker network prune 

-# Remove Network
docker network rm <networkNameOrId>

Docker Host Network.:
If we create containers in host network. Container will not have IP Address.
 Container will be created in a system network.

But we can't create more than one container with same container port in host network.
We no need to do port publish to access  containers.
   landmark-web-app  = containerPort,  EXPOSE=8080  
   java-web-app      = containerPort,  EXPOSE=8080  
   maven-web-app     = containerPort,  EXPOSE=8080  

   docker run --network bridge --name landmark -d -p 6000:8080
   docker run --network bridge --name javaapp -d -p  7000:8080
   docker run --network bridge --name mavenapp -d -p 5500:8080

   docker run --ebay host -d --name hello mylandmarktech/hello
   docker run --network host -d --name webserver nginx


   docker run --network ebay -d -p 90:80 --name hello2 mylandmarktech/hello 
     netstat -tulpn  

Docker none/null network
========================
If we create container in none/null network. Container will not have IP Address.
We can't access  containers in this network  
docker run --network none                     
Internal or external 

Isolation
  docker run --ebay host -d --name hello mylandmarktech/hello   
  docker disconnect hello ebay  
  docker connect hello none  


docker run --name springapp -d -p 4000:8080 --network tesla -e MONGO_DB_USERNAME=devdb \
 -e MONGO_DB_PASSWORD=dev@123 -e MONGO_DB_HOSTNAME=mongo mylandmarktech/spring-boot-mongo

docker run --name mongo -d --network tesla -e MONGO_INITDB_ROOT_PASSWORD=dev@123 \
 -e MONGO_INITDB_ROOT_USERNAME=devdb mongo 

 docker run --name springapp --network tesla  -d -p 4000:8080 -e MONGO_DB_USERNAME=nancy \
 -e MONGO_DB_PASSWORD=rich@2023 -e MONGO_DB_HOSTNAME=mydb mylandmarktech/spring-boot-mongo

docker run --name mydb -d --network tesla -e MONGO_INITDB_ROOT_PASSWORD=rich@2023 \
 -e MONGO_INITDB_ROOT_USERNAME=nancy mongo 